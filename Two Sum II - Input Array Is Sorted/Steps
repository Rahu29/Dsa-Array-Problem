Leetcode 167 ->
Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length.
Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.
The tests are generated such that there is exactly one solution. You may not use the same element twice.
Your solution must use only constant extra space.

Example 1:
Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Solution ->
1) Create a method signature twoSum() with return type int[] for return indexs of two element and take parameter as int[] arr and int target.
2) Create a hasmap for storing current element and index.
3) create a int[] res for storing final result.
4) Run a for loop from 0 to arr.length -
    1) Check condition if target-currentElement is present as a key inside a map or not-
        1) If true then get value of key target-currentElement from map and add 1 to it(Array index is based on 1 not 0 that's why we have added 1), add this to res[0].
    2) else -
        1) If above condition false then simply add currentElement in hashmap as a key and current index as a value.
5) Return res
6) END.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Debugging ->

1) Iteration i = 0
    1) Current element = numbers[0] = 2
    2) Calculate complement = target - numbers[i] = 9 - 2 = 7
    3) Check map.containsKey(7) → false
    4) Put element into map → map.put(2, 0)
    5) map = {2=0}
2) Iteration i = 1
    1) Current element = numbers[1] = 7
    2) Calculate complement = 9 - 7 = 2
    3) Check map.containsKey(2) → true
    4) Assign res[0] = map.get(2) + 1 → 0 + 1 = 1
    5) Assign res[1] = i + 1 → 1 + 1 = 2
    6) Pair found → indices (1, 2)
3) Iteration i = 2
    1) Current element = numbers[2] = 11
    2) Calculate complement = 9 - 11 = -2
    3) Check map.containsKey(-2) → false
    4) Put element into map → map.put(11, 2)
    5) map = {2=0, 11=2}
4) Iteration i = 3
    1) Current element = numbers[3] = 15
    2) Calculate complement = 9 - 15 = -6
    3) Check map.containsKey(-6) → false
    4) Put element into map → map.put(15, 3)
    5) map = {2=0, 11=2, 15=3}
5) Return res.
6) END
